#!/usr/bin/env node

/**
 * Schema Generation Script
 * Converts YAML schema files from the schemas submodule to JavaScript modules
 * for use in the Chrome extension.
 *
 * Usage: node scripts/generate-schemas.js
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

const TABLES = [
  'imp_join_all2',
  'creative_event',
  'creative_perf_event',
  'creative_quality'
];

const SCHEMAS_DIR = path.join(__dirname, '..', 'schemas', 'spark');
const OUTPUT_DIR = path.join(__dirname, '..', 'src', 'js', 'schemas');

/**
 * Flatten nested fields with dot notation
 * @param {Array} fields - Array of field definitions from YAML
 * @param {string} prefix - Prefix for nested field names
 * @returns {Array} Flattened array of {name, type} objects
 */
function flattenFields(fields, prefix = '') {
  const result = [];

  for (const field of fields) {
    const fieldName = prefix ? `${prefix}.${field.name}` : field.name;
    const fieldType = parseFieldType(field.type);

    if (fieldType.isStruct && fieldType.fields) {
      // Recursively flatten struct fields
      result.push(...flattenFields(fieldType.fields, fieldName));
    } else if (fieldType.isArray && fieldType.elementFields) {
      // For arrays of structs, add the array field with element info AND flatten sub-fields
      result.push({
        name: fieldName,
        type: fieldType.type,
        isArrayStruct: true,
        elementFields: fieldType.elementFields.map(ef => ({
          name: ef.name,
          type: typeof ef.type === 'string' ? ef.type : (ef.type.type || 'unknown')
        }))
      });
      // Also add flattened sub-fields for direct access
      result.push(...flattenFields(fieldType.elementFields, fieldName));
    } else if (fieldType.isArray) {
      // Array of primitives - preserve array info
      result.push({
        name: fieldName,
        type: fieldType.type,
        isArrayPrimitive: true,
        elementType: fieldType.elementType || 'unknown'
      });
    } else {
      // Simple field
      result.push({
        name: fieldName,
        type: fieldType.type
      });
    }
  }

  return result;
}

/**
 * Parse field type from YAML (handles complex types)
 * @param {string|object} type - Type definition from YAML
 * @returns {object} Parsed type info
 */
function parseFieldType(type) {
  if (typeof type === 'string') {
    return { type, isStruct: false, isArray: false };
  }

  if (type.type === 'struct') {
    return {
      type: 'struct',
      isStruct: true,
      isArray: false,
      fields: type.fields
    };
  }

  if (type.type === 'array') {
    const elementType = type.elementType;

    if (typeof elementType === 'object' && elementType.type === 'struct') {
      return {
        type: 'array<struct>',
        isStruct: false,
        isArray: true,
        elementFields: elementType.fields
      };
    }

    // Array of primitives
    const primitiveType = typeof elementType === 'string' ? elementType : elementType.type || 'unknown';
    return {
      type: `array<${primitiveType}>`,
      isStruct: false,
      isArray: true,
      elementType: primitiveType
    };
  }

  if (type.type === 'map') {
    return {
      type: 'map',
      isStruct: false,
      isArray: false
    };
  }

  return { type: 'unknown', isStruct: false, isArray: false };
}

/**
 * Convert table name to JavaScript variable name
 * @param {string} tableName - Table name (e.g., 'imp_join_all2')
 * @returns {string} Variable name (e.g., 'IMP_JOIN_ALL2_SCHEMA')
 */
function toVariableName(tableName) {
  return tableName.toUpperCase().replace(/-/g, '_') + '_SCHEMA';
}

/**
 * Generate JavaScript content for a schema
 * @param {string} tableName - Table name
 * @param {Array} fields - Flattened fields array
 * @returns {string} JavaScript file content
 */
function generateSchemaJS(tableName, fields) {
  const varName = toVariableName(tableName);
  const fieldsJson = JSON.stringify(fields, null, 2)
    .split('\n')
    .map((line, i) => i === 0 ? line : '  ' + line)
    .join('\n');

  return `/**
 * Auto-generated schema for ${tableName}
 * Generated by: node scripts/generate-schemas.js
 * Source: schemas/spark/${tableName}.yaml
 *
 * DO NOT EDIT MANUALLY - regenerate with: make update-spark-schema
 */

const ${varName} = {
  name: "${tableName}",
  fields: ${fieldsJson}
};
`;
}

/**
 * Generate index.js that exports all schemas
 * @param {Array} tables - Array of table names
 * @returns {string} JavaScript file content
 */
function generateIndexJS(tables) {
  const imports = tables.map(t => `// ${t} schema is loaded via script tag`).join('\n');
  const schemaMap = tables.map(t => `  "${t}": ${toVariableName(t)}`).join(',\n');

  return `/**
 * Schema Index
 * Auto-generated - DO NOT EDIT MANUALLY
 *
 * This file provides a mapping of table names to their schemas.
 * Individual schema files are loaded via script tags in popup.html.
 */

const TABLE_SCHEMAS = {
${schemaMap}
};

/**
 * Get schema for a table
 * @param {string} tableName - Table name
 * @returns {object|null} Schema object or null if not found
 */
function getTableSchema(tableName) {
  return TABLE_SCHEMAS[tableName] || null;
}

/**
 * Get list of supported table names
 * @returns {Array} Array of table names
 */
function getSupportedTables() {
  return Object.keys(TABLE_SCHEMAS);
}
`;
}

/**
 * Main function
 */
function main() {
  console.log('Generating schemas from YAML files...\n');

  // Ensure output directory exists
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }

  const generatedTables = [];

  for (const tableName of TABLES) {
    const yamlPath = path.join(SCHEMAS_DIR, `${tableName}.yaml`);

    if (!fs.existsSync(yamlPath)) {
      console.warn(`Warning: ${yamlPath} not found, skipping...`);
      continue;
    }

    try {
      console.log(`Processing ${tableName}...`);

      const yamlContent = fs.readFileSync(yamlPath, 'utf8');
      const schema = yaml.load(yamlContent);

      if (!schema.schema || !schema.schema.fields) {
        console.warn(`Warning: ${tableName} has no schema.fields, skipping...`);
        continue;
      }

      // Add partition field (_dt) if present
      const fields = [...schema.schema.fields];
      if (schema.partition_spec && schema.partition_spec.fields) {
        for (const partField of schema.partition_spec.fields) {
          fields.push(partField);
        }
      }

      const flattenedFields = flattenFields(fields);
      const jsContent = generateSchemaJS(tableName, flattenedFields);
      const outputPath = path.join(OUTPUT_DIR, `${tableName}.js`);

      fs.writeFileSync(outputPath, jsContent);
      console.log(`  -> Generated ${outputPath} (${flattenedFields.length} fields)`);

      generatedTables.push(tableName);
    } catch (error) {
      console.error(`Error processing ${tableName}: ${error.message}`);
    }
  }

  // Generate index.js
  if (generatedTables.length > 0) {
    const indexContent = generateIndexJS(generatedTables);
    const indexPath = path.join(OUTPUT_DIR, 'index.js');
    fs.writeFileSync(indexPath, indexContent);
    console.log(`\nGenerated ${indexPath}`);
  }

  console.log(`\nDone! Generated schemas for ${generatedTables.length} tables.`);
}

main();
