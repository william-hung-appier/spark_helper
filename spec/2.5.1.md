# JOIN Key Custom Field Resolution Fix

## Context/Background

- When using JOIN mode, users can select custom-mapped fields (like `bidobjid`) as JOIN keys
- Custom fields have SQL expressions defined in mappings (e.g., `bidobjid` → `BYTES2STR(bid_appier_id)`)
- The ON clause was using raw field names instead of resolving custom field SQL expressions

## AS-IS (Before v2.5.1)

When selecting `bidobjid` as JOIN key between `imp_join_all2` and `creative_event`:

```sql
ON t1.bidobjid = t2.bidobjid
```

**Problem:** `bidobjid` doesn't exist as a column in `imp_join_all2`. It's a custom mapping that translates to `BYTES2STR(bid_appier_id)`. The query would fail at runtime.

## TO-BE (v2.5.1 Implementation)

Custom field mappings are now resolved in the ON clause:

```sql
ON BYTES2STR(t1.bid_appier_id) = t2.bidobjid
```

The resolution handles:
1. Custom mappings with SQL expressions (prefixes field references with table alias)
2. Binary fields (auto-wraps with `BYTES2STR()`)
3. Regular fields (simple table alias prefix)

## Implementation Details

### New Method: `resolveOnFieldExpression()`

Resolves a field name to its SQL expression for use in JOIN ON clause:

```javascript
resolveOnFieldExpression(fieldName, tableName, alias) {
  // 1. Check for custom mapping
  const mappings = TABLE_MAPPINGS[tableName];
  const customField = mappings?.fields?.[fieldName];

  if (customField && customField.sql) {
    // Prefix field references in the SQL with table alias
    // "BYTES2STR(bid_appier_id)" → "BYTES2STR(t1.bid_appier_id)"
    return prefixFieldReferences(customField.sql, alias);
  }

  // 2. Check for binary field
  if (isBinaryField(fieldName, tableName)) {
    return `BYTES2STR(${alias}.${fieldName})`;
  }

  // 3. Regular field
  return `${alias}.${fieldName}`;
}
```

### Updated `buildOnClause()`

Now accepts table names and uses the resolver:

```javascript
buildOnClause(field1, field2, table1, table2) {
  const expr1 = this.resolveOnFieldExpression(field1, table1, 't1');
  const expr2 = this.resolveOnFieldExpression(field2, table2, 't2');
  return `ON ${expr1} = ${expr2}`;
}
```

### Field Reference Prefixing

The SQL expression parsing handles common Spark UDF patterns:

| Original SQL | Prefixed SQL |
|--------------|--------------|
| `BYTES2STR(bid_appier_id)` | `BYTES2STR(t1.bid_appier_id)` |
| `CID2OID(cid)` | `CID2OID(t1.cid)` |
| `NVL(field, '')` | `NVL(t1.field, '')` |

Function names and SQL keywords are preserved (not prefixed).

## Acceptance Criteria

- [x] Custom-mapped fields resolve to their SQL expressions in ON clause
- [x] Field references within SQL expressions are prefixed with table alias
- [x] Binary fields are wrapped with `BYTES2STR()` if not already custom-mapped
- [x] Regular fields use simple `alias.fieldName` format
- [x] Both t1 and t2 fields are resolved independently based on their table's mappings

## Files Changed

| File | Changes |
|------|---------|
| `src/js/queryBuilder.js` | Added `resolveOnFieldExpression()` method, updated `buildOnClause()` to accept table names and resolve custom field SQL |
| `manifest.json` | Version bump to 2.5.1 |

---

# Save Snippet Validation Fix for JOIN Mode

## Context/Background

- "Save as Snippet" button was showing "Please add at least one field" error even when fields were present in JOIN mode
- The validation was only checking standard mode field container, not the JOIN mode t1/t2 containers

## AS-IS (Before Fix)

When in JOIN mode with fields in t1/t2 sections, clicking "Save as Snippet":

```
Alert: "Please add at least one field"
```

The validation checked `ui.getFieldRowsData()` which reads from the standard mode container (empty in JOIN mode).

## TO-BE (After Fix)

Save as Snippet now correctly detects JOIN mode and validates the appropriate field containers:

1. Detects JOIN mode via `appState.isJoinEnabled()`
2. Validates fields from `getFieldRowsDataForTable('t1')` and `getFieldRowsDataForTable('t2')`
3. Saves JOIN configuration (joinConfig, fieldRowsT2) with the snippet

## Implementation Details

### Updated Save Snippet Handler

```javascript
if (appState.isJoinEnabled()) {
  const fieldRowsT1 = ui.getFieldRowsDataForTable("t1");
  const fieldRowsT2 = ui.getFieldRowsDataForTable("t2");

  const hasT1Fields = fieldRowsT1.length > 0 && fieldRowsT1[0].fieldName;
  const hasT2Fields = fieldRowsT2.length > 0 && fieldRowsT2[0].fieldName;

  if (!hasT1Fields && !hasT2Fields) {
    alert("Please add at least one field");
    return;
  }

  // Save with JOIN config
  snippetManager.createFromQuery({
    name, queryType, tableName,
    fieldRows: fieldRowsT1,
    fieldRowsT2: fieldRowsT2,
    conditionRows,
    joinConfig
  });
}
```

### Extended SnippetManager

- `createFromQuery()` now accepts optional `joinConfig` and `fieldRowsT2` parameters
- Added `_generateJoinPreview()` for JOIN query previews

## Acceptance Criteria

- [x] Save as Snippet works in JOIN mode when fields are present in t1 or t2
- [x] JOIN configuration is saved with the snippet
- [x] Preview shows JOIN query format for JOIN snippets
- [x] Standard mode behavior unchanged

## Additional Files Changed

| File | Changes |
|------|---------|
| `src/js/app.js` | Updated save snippet handler to detect JOIN mode and validate correct field containers |
| `src/js/snippetManager.js` | Extended `createFromQuery()` for JOIN support, added `_generateJoinPreview()` |

---

# Type-Aware Value Quoting in WHERE Clause

## Context/Background

- When building WHERE conditions, all values were being quoted as strings (e.g., `imp_type = '2'`)
- For numeric fields like `imp_type` (integer), the query should use unquoted values (e.g., `imp_type = 2`)
- The schema already contains type information but it wasn't being used for value formatting

## AS-IS (Before Fix)

When adding a WHERE condition `imp_type = 2`:

```sql
WHERE imp_type = '2'
```

**Problem:** `imp_type` is an integer field. Comparing with a quoted string `'2'` returns no results because Spark treats it as a string comparison.

## TO-BE (After Fix)

The query builder now uses schema type information to determine value quoting:

```sql
WHERE imp_type = 2
```

### Quoting Logic

| Field Type | Value | Output |
|------------|-------|--------|
| `integer` | `2` | `imp_type = 2` (no quotes) |
| `integer` | `abc` | `imp_type = 'abc'` (quoted - value is non-numeric) |
| `string` | `ios` | `os = 'ios'` (quoted) |
| `custom` | `fyber_use` | `partner_id = 'fyber_use'` (quoted - custom functions return strings) |

## Implementation Details

### New Methods in `queryBuilder.js`

```javascript
isNumericType(fieldType) {
  const numericTypes = ['integer', 'int', 'long', 'double', 'float', 'decimal', 'short', 'byte'];
  return numericTypes.includes(fieldType?.toLowerCase());
}

isNumericValue(value) {
  // Match integers, decimals, negative numbers, scientific notation
  return /^-?\d+\.?\d*([eE][+-]?\d+)?$/.test(String(value).trim());
}
```

### Updated `buildFieldCondition()`

```javascript
// Only skip quotes if BOTH field is numeric AND value is numeric
const isNumericField = !isCustom && this.isNumericType(resolvedType);
const shouldQuote = !(isNumericField && this.isNumericValue(value));
const formattedValue = shouldQuote ? `'${escapedValue}'` : escapedValue;
```

### New Methods in Schema Layer

- `schemaParser.js`: Added `getFieldType(fieldName)` to retrieve field type from schema
- `state.js`: Added `getFieldType(fieldName)` to expose schema lookup

## Acceptance Criteria

- [x] Numeric fields with numeric values are not quoted
- [x] Numeric fields with non-numeric values are still quoted (safeguard)
- [x] String fields are always quoted
- [x] Custom function fields are always quoted (they return strings)
- [x] Works for both `=` operator and `IN`/`NOT IN` operators
- [x] Works in both standard mode and JOIN mode

## Files Changed

| File | Changes |
|------|---------|
| `src/js/queryBuilder.js` | Added `isNumericType()`, `isNumericValue()`, updated `buildFieldCondition()` and `buildWherePartWithPrefix()` |
| `src/js/schemaParser.js` | Added `getFieldType()` method |
| `src/js/state.js` | Added `getFieldType()` method |
| `src/js/ui.js` | Added `fieldType` to condition data collection |

---

# Custom Function SQL in WHERE Clause

## Context/Background

- Custom-mapped fields like `partner_id` have SQL expressions (e.g., `NVL(PARTNERID2STR(partner_id), '')`)
- In SELECT clause, these expressions were correctly applied
- In WHERE clause, only the raw field name was used, causing incorrect comparisons

## AS-IS (Before Fix)

When selecting `partner_id` (custom mapping) in WHERE with value `fyber_use`:

```sql
WHERE partner_id = 'fyber_use'
```

**Problem:** The raw `partner_id` field is an integer. The custom mapping converts it to a string using `PARTNERID2STR()`. Without the function, the comparison fails.

## TO-BE (After Fix)

Custom field SQL expressions are now applied in WHERE clause:

```sql
WHERE NVL(PARTNERID2STR(partner_id), '') = 'fyber_use'
```

## Implementation Details

### Updated Data Collection

`getConditionRowsData()` now includes `sql` and `isCustom` properties:

```javascript
baseData = {
  type: 'field',
  fieldName: selectedItem.value,
  fieldType: selectedItem.type,
  isCustom: selectedItem.isCustom,
  sql: selectedItem.sql || null,
  // ...
};
```

### Updated `buildFieldCondition()`

```javascript
let fieldExpr;
if (isCustom && sql) {
  // Use custom SQL expression directly
  fieldExpr = sql;
} else {
  // Regular field handling
  const prefixedField = prefix ? `${prefix}.${fieldName}` : fieldName;
  fieldExpr = isBinaryField ? `BYTES2STR(${prefixedField})` : prefixedField;
}
```

## Acceptance Criteria

- [x] Custom-mapped fields use their SQL expression in WHERE clause
- [x] Schema fields without custom mappings use raw field name
- [x] Binary fields are wrapped with `BYTES2STR()` if not custom-mapped
- [x] Works for all operators (`=`, `IN`, `NOT IN`)
- [x] Works in both standard mode and JOIN mode

## Files Changed

| File | Changes |
|------|---------|
| `src/js/queryBuilder.js` | Updated `buildFieldCondition()` and `buildWherePartWithPrefix()` to use custom SQL |
| `src/js/ui.js` | Updated `getConditionRowsData()` to include `sql` and `isCustom`, updated onSelect handlers to store on row dataset |

---

# Field Data Persistence Fix (Regeneration Bug)

## Context/Background

- After generating a query, pressing "Clear" then "Generate Query" again caused custom fields to lose their SQL expressions
- The autocomplete's `selectedItem` was being lost when the input received any modification
- Fields like `bidobjid`, `partner_id`, `os` would show broken SQL on regeneration

## AS-IS (Before Fix)

First generation:
```sql
SELECT
  NVL(BYTES2STR(bid_appier_id), '') AS bidobjid,
  NVL(PARTNERID2STR(partner_id), '') AS partner_id
```

After Clear → Generate again:
```sql
SELECT
  bidobjid AS bidobjid,
  partner_id AS partner_id
```

**Problem:** The `selectedItem` in autocomplete was null after certain interactions, causing fallback to raw input text.

## TO-BE (After Fix)

Field data is now persisted on the DOM row element as a backup. When `selectedItem` is lost, the system recovers from `row.dataset`:

```sql
-- Works correctly on all regenerations
SELECT
  NVL(BYTES2STR(bid_appier_id), '') AS bidobjid,
  NVL(PARTNERID2STR(partner_id), '') AS partner_id
```

## Implementation Details

### New Method in Autocomplete

```javascript
setSelectedItem(item) {
  if (!item) return;
  this.selectedItem = item;
  this.currentValue = item.value;
  this.input.value = item.label || item.value;
}
```

### Field Data Storage on Row

When a field is selected, essential data is stored on `row.dataset`:

```javascript
handleFieldSelect(item, aliasInput, fieldRow) {
  // Store for recovery
  fieldRow.dataset.fieldName = item.value;
  fieldRow.dataset.fieldType = item.type || '';
  fieldRow.dataset.isCustom = item.isCustom ? 'true' : 'false';
  fieldRow.dataset.isBinary = item.isBinary ? 'true' : 'false';
  if (item.sql) fieldRow.dataset.sql = item.sql;
  if (item.alias) fieldRow.dataset.itemAlias = item.alias;
  // ...
}
```

### Fallback Logic in Data Collection

```javascript
getFieldRowsData() {
  const selectedItem = autocomplete?.getSelectedItem();
  const hasRowData = row.dataset.fieldName;

  if (selectedItem) {
    // Use selectedItem (preferred)
  } else if (hasRowData) {
    // Fallback to row dataset
  } else {
    // Last resort - use input value
  }
}
```

## Acceptance Criteria

- [x] Custom fields retain their SQL expressions after Clear → Generate
- [x] Field data persists across multiple regenerations
- [x] History restoration properly restores field data
- [x] Snippet loading properly restores field data
- [x] Works for SELECT fields and WHERE condition fields
- [x] Works in both standard mode and JOIN mode

## Files Changed

| File | Changes |
|------|---------|
| `src/js/autocomplete.js` | Added `setSelectedItem()` method |
| `src/js/ui.js` | Updated `handleFieldSelect()` to store data on row, updated `getFieldRowsData()` and `getFieldRowsDataForTable()` with fallback logic, updated `addFieldRowWithData()` and `addFieldRowForTableWithData()` to use `setSelectedItem()` and store row data |

---

# Visual Type Badges in WHERE Conditions

## Context/Background

- Users couldn't easily see what type a field was when adding WHERE conditions
- This made it unclear whether values would be quoted or not

## Implementation

Added visual type badges that appear next to the field autocomplete when a field is selected:

| Badge | Color | Meaning |
|-------|-------|---------|
| `int` | Green | Numeric field (integer, long, double, etc.) |
| `str` | Blue | String field |
| `bin` | Blue | Binary field |
| `fn` | Purple | Custom function/mapping |

### CSS Styling

```css
.field-type-badge {
  display: inline-flex;
  padding: 2px 6px;
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  border-radius: var(--radius-sm);
}

.field-type-badge.type-integer { background: rgba(34, 197, 94, 0.15); color: #16a34a; }
.field-type-badge.type-string { background: rgba(59, 130, 246, 0.15); color: #2563eb; }
.field-type-badge.type-custom { background: rgba(168, 85, 247, 0.15); color: #9333ea; }
```

### UI Method

```javascript
updateConditionTypeBadge(conditionRow, fieldType, isCustom) {
  // Remove existing badge
  // Determine display type and color class
  // Create and insert badge element
}
```

## Acceptance Criteria

- [x] Type badge appears when field is selected in WHERE condition
- [x] Badge shows appropriate type indicator
- [x] Badge uses correct color based on type category
- [x] Badge is removed/updated when field selection changes
- [x] Works with dark mode

## Files Changed

| File | Changes |
|------|---------|
| `src/js/ui.js` | Added `updateConditionTypeBadge()` method, called from onSelect handlers |
| `src/css/styles.css` | Added `.field-type-badge` styles with type-specific colors |
