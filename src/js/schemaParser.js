const SCHEMA_URL = 'https://data-catalog.dp.arepa.appier.info/schema/view/imp_join_all2';

class SchemaParser {
  constructor(fieldMappings) {
    this.fieldMappings = fieldMappings;
  }

  parseHtml(htmlString) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlString, 'text/html');
    const rows = doc.querySelectorAll('table#tb_sortable tbody tr');

    return Array.from(rows)
      .map(row => this.parseRow(row))
      .filter(Boolean);
  }

  parseRow(row) {
    const cells = row.querySelectorAll('td');
    if (cells.length < 3) return null;

    const fieldName = this.extractFieldName(cells[1]);
    const fieldType = cells[2].textContent.trim();

    if (!fieldName || !fieldType) return null;

    return { name: fieldName, type: fieldType, isCustomize: false };
  }

  extractFieldName(cell) {
    const fontTag = cell.querySelector('font[color="silver"]');
    if (!fontTag) return cell.textContent.trim();

    const prefix = fontTag.textContent;
    const suffix = cell.textContent.replace(prefix, '').trim();
    return prefix + suffix;
  }

  isFieldCoveredByMapping(fieldName) {
    return Object.values(this.fieldMappings).some(mapping => mapping.sql.includes(fieldName));
  }

  generateBinaryFieldMappings(schemaFields) {
    const binaryMappings = {};

    schemaFields.forEach(field => {
      if (field.type !== 'binary') return;

      const baseName = this.getBaseName(field.name);
      if (this.isFieldCoveredByMapping(field.name) || this.isFieldCoveredByMapping(baseName)) return;
      if (binaryMappings[baseName]) return;

      binaryMappings[baseName] = {
        sql: `BYTES2STR(${field.name})`,
        alias: baseName,
        isAutoGenerated: true
      };
    });

    return binaryMappings;
  }

  getBaseName(fieldName) {
    return fieldName.includes('.') ? fieldName.split('.').pop() : fieldName;
  }

  mergeWithCustomizeFields(schemaFields) {
    const mergedFields = [];
    const addedFieldNames = new Set();

    Object.keys(this.fieldMappings).forEach(fieldName => {
      mergedFields.push({
        name: fieldName,
        type: 'Customize',
        isCustomize: true,
        isAutoGenerated: false
      });
      addedFieldNames.add(fieldName);
    });

    const binaryMappings = this.generateBinaryFieldMappings(schemaFields);
    Object.keys(binaryMappings).forEach(fieldName => {
      if (addedFieldNames.has(fieldName)) return;

      mergedFields.push({
        name: fieldName,
        type: 'Customize',
        isCustomize: true,
        isAutoGenerated: true,
        mapping: binaryMappings[fieldName]
      });
      addedFieldNames.add(fieldName);
    });

    schemaFields.forEach(field => {
      const baseName = this.getBaseName(field.name);
      if (addedFieldNames.has(baseName) || addedFieldNames.has(field.name)) return;

      mergedFields.push(field);
      addedFieldNames.add(field.name);
    });

    return mergedFields;
  }

  async fetchSchemaFields() {
    try {
      const response = await fetch(SCHEMA_URL, { credentials: 'include' });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const html = await response.text();
      const hasValidSchema = html.includes('tb_sortable') && html.includes('imp_join_all2');

      if (!hasValidSchema) {
        console.log('Schema page not accessible, using fallback HTML');
        return this.parseHtml(DEFAULT_FALLBACK_HTML);
      }

      return this.parseHtml(html);
    } catch (error) {
      console.log('Failed to fetch schema, using fallback HTML:', error.message);
      return this.parseHtml(DEFAULT_FALLBACK_HTML);
    }
  }

  async getAvailableFields() {
    const schemaFields = await this.fetchSchemaFields();
    return this.mergeWithCustomizeFields(schemaFields);
  }
}