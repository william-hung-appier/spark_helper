class QueryBuilder {
  constructor(fieldMappings, whereConditions) {
    this.fieldMappings = fieldMappings;
    this.whereConditions = whereConditions;
  }

  parseDateTimeInput(dateTimeStr) {
    if (!dateTimeStr) return null;

    const parts = dateTimeStr.split('-');
    const isValidLength = parts.length >= 3 && parts.length <= 4;
    if (!isValidLength) return null;

    const year = parseInt(parts[0], 10);
    const month = parseInt(parts[1], 10);
    const day = parseInt(parts[2], 10);
    const hour = parts.length === 4 ? parseInt(parts[3], 10) : 0;

    const hasInvalidNumber = [year, month, day, hour].some(isNaN);
    if (hasInvalidNumber) return null;

    return { year, month, day, hour };
  }

  formatDateTimeToUTC(dateTimeStr, timezoneOffset) {
    const parsed = this.parseDateTimeInput(dateTimeStr);
    if (!parsed) return dateTimeStr;

    const { year, month, day, hour } = parsed;
    const offsetHours = parseInt(timezoneOffset, 10);
    const utcDate = new Date(Date.UTC(year, month - 1, day, hour - offsetHours));

    const utcYear = utcDate.getUTCFullYear();
    const utcMonth = String(utcDate.getUTCMonth() + 1).padStart(2, '0');
    const utcDay = String(utcDate.getUTCDate()).padStart(2, '0');
    const utcHour = String(utcDate.getUTCHours()).padStart(2, '0');

    return `${utcYear}${utcMonth}${utcDay}${utcHour}`;
  }

  buildSelectPart(fieldData) {
    const { fieldType, isCustomize, isAutoGenerated, mappingSql, mappingAlias, alias } = fieldData;

    if (!fieldType) return null;

    if (fieldType === 'custom') {
      return alias ? `  ${alias}` : null;
    }

    if (!isCustomize) {
      const finalAlias = alias || fieldType;
      return `  ${fieldType} AS ${finalAlias}`;
    }

    if (isAutoGenerated) {
      const sql = decodeURIComponent(mappingSql || '');
      const finalAlias = alias || mappingAlias || fieldType;
      return `  ${sql} AS ${finalAlias}`;
    }

    const mapping = this.fieldMappings[fieldType];
    if (!mapping) return null;

    const finalAlias = alias || mapping.alias;
    return `  ${mapping.sql} AS ${finalAlias}`;
  }

  buildWherePart(conditionType, customValue) {
    if (!conditionType) return null;

    if (conditionType === 'custom') {
      return customValue ? `  ${customValue}` : null;
    }

    const condition = this.whereConditions[conditionType];
    return condition ? `  ${condition.sql}` : null;
  }

  buildFromClause(tableName, startTime, endTime, timezone) {
    if (!startTime || !endTime) return tableName;

    const adjustedStart = this.formatDateTimeToUTC(startTime, timezone);
    const adjustedEnd = this.formatDateTimeToUTC(endTime, timezone);
    return `${tableName}_${adjustedStart}_${adjustedEnd}`;
  }

  generate(config) {
    const { fieldRows, conditionRows, tableName, startTime, endTime, timezone, isDistinct } = config;

    const selectParts = fieldRows
      .map(row => this.buildSelectPart(row))
      .filter(Boolean);

    const whereParts = conditionRows
      .map(row => this.buildWherePart(row.conditionType, row.customValue))
      .filter(Boolean);

    const fromClause = this.buildFromClause(tableName, startTime, endTime, timezone);

    let query = isDistinct ? 'SELECT DISTINCT\n' : 'SELECT\n';

    if (selectParts.length > 0) {
      query += selectParts.join(',\n');
    }

    query += '\nFROM\n';
    query += `  ${fromClause}`;

    if (whereParts.length > 0) {
      query += '\nWHERE\n';
      query += whereParts.join('\n  AND ');
    }

    return query;
  }
}