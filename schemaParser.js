// Schema Parser - Parses HTML table to extract field names and types
// URL for the imp_join_all2 schema page
const SCHEMA_URL = 'https://data-catalog.dp.arepa.appier.info/schema/view/imp_join_all2';

// Parse HTML string to extract field names and types
function parseSchemaHtml(htmlString) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(htmlString, 'text/html');
  const fields = [];

  // Find all table rows in tbody
  const rows = doc.querySelectorAll('table#tb_sortable tbody tr');

  rows.forEach(row => {
    const cells = row.querySelectorAll('td');
    if (cells.length >= 3) {
      // Column 1 (index 1) is Field Name, Column 2 (index 2) is Field Type
      let fieldName = cells[1].textContent.trim();
      const fieldType = cells[2].textContent.trim();

      // Remove the gray prefix (e.g., "<font color="silver">actions[].</font>")
      // The actual field name is the text after the font tag
      const fontTag = cells[1].querySelector('font[color="silver"]');
      if (fontTag) {
        // Get text after the font tag
        fieldName = cells[1].textContent.replace(fontTag.textContent, '').trim();
        // Also include the prefix for context
        const prefix = fontTag.textContent;
        fieldName = prefix + fieldName;
      }

      if (fieldName && fieldType) {
        fields.push({
          name: fieldName,
          type: fieldType,
          isCustomize: false
        });
      }
    }
  });

  return fields;
}

// Check if a field is already covered by an existing FIELD_MAPPING
function isFieldCoveredByMapping(fieldName) {
  for (const mapping of Object.values(FIELD_MAPPINGS)) {
    // Check if the SQL expression references this field
    if (mapping.sql.includes(fieldName)) {
      return true;
    }
  }
  return false;
}

// Generate auto BYTES2STR mappings for binary fields
function generateBinaryFieldMappings(schemaFields) {
  const binaryMappings = {};

  schemaFields.forEach(field => {
    if (field.type === 'binary') {
      // Extract base field name (without prefix like "actions[].")
      const baseName = field.name.includes('.')
        ? field.name.split('.').pop()
        : field.name;

      // Skip if already covered by an existing mapping
      if (isFieldCoveredByMapping(field.name) || isFieldCoveredByMapping(baseName)) {
        return;
      }

      // Skip if already added (avoid duplicates from nested fields)
      if (binaryMappings[baseName]) {
        return;
      }

      // Create auto-generated BYTES2STR mapping
      binaryMappings[baseName] = {
        sql: `BYTES2STR(${field.name})`,
        alias: baseName,
        isAutoGenerated: true
      };
    }
  });

  return binaryMappings;
}

// Merge schema fields with customize fields from FIELD_MAPPINGS
function mergeWithCustomizeFields(schemaFields) {
  const customizeFieldNames = Object.keys(FIELD_MAPPINGS);
  const mergedFields = [];
  const addedFieldNames = new Set();

  // First, add all manual customize fields with isCustomize = true
  customizeFieldNames.forEach(fieldName => {
    mergedFields.push({
      name: fieldName,
      type: 'Customize',
      isCustomize: true,
      isAutoGenerated: false
    });
    addedFieldNames.add(fieldName);
  });

  // Second, add auto-generated BYTES2STR mappings for binary fields
  const binaryMappings = generateBinaryFieldMappings(schemaFields);
  Object.keys(binaryMappings).forEach(fieldName => {
    if (!addedFieldNames.has(fieldName)) {
      mergedFields.push({
        name: fieldName,
        type: 'Customize',
        isCustomize: true,
        isAutoGenerated: true,
        mapping: binaryMappings[fieldName]
      });
      addedFieldNames.add(fieldName);
    }
  });

  // Then add schema fields that are not already in customize fields
  schemaFields.forEach(field => {
    // Extract the base field name (without prefix like "actions[].")
    const baseName = field.name.includes('.')
      ? field.name.split('.').pop()
      : field.name;

    if (!addedFieldNames.has(baseName) && !addedFieldNames.has(field.name)) {
      mergedFields.push(field);
      addedFieldNames.add(field.name);
    }
  });

  return mergedFields;
}

// Format field option display text
function formatFieldOption(field) {
  if (field.isCustomize) {
    if (field.isAutoGenerated) {
      return `${field.name} | BYTES2STR`;
    }
    return `${field.name} | Customize`;
  }
  return `${field.name} | ${field.type}`;
}

// Fetch schema from the webpage with fallback to default HTML
async function fetchSchemaFields() {
  try {
    const response = await fetch(SCHEMA_URL, {
      credentials: 'include' // Include cookies for authentication
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const html = await response.text();

    // Check if the response contains the expected table structure
    // If not logged in, the page might redirect or show login page
    if (!html.includes('tb_sortable') || !html.includes('imp_join_all2')) {
      console.log('Schema page not accessible, using fallback HTML');
      return parseSchemaHtml(DEFAULT_FALLBACK_HTML);
    }

    return parseSchemaHtml(html);
  } catch (error) {
    console.log('Failed to fetch schema, using fallback HTML:', error.message);
    return parseSchemaHtml(DEFAULT_FALLBACK_HTML);
  }
}

// Get all available fields (merged with customize fields)
async function getAvailableFields() {
  const schemaFields = await fetchSchemaFields();
  return mergeWithCustomizeFields(schemaFields);
}
